#!/usr/bin/env bash
set -euo pipefail

# ============================================================================
# rlm — Unix RLM: an RLM whose sandbox is a full Linux filesystem
# ============================================================================
#
# Usage: rlm "query"
#        echo "data" | rlm "query"
#
# Environment variables (configuration):
#   OPENROUTER_API_KEY   — OpenRouter API key (or read from /etc/rlm/api-key)
#   RLM_MODEL            — OpenRouter model identifier
#   RLM_MAX_ITERATIONS   — Max loop iterations per invocation
#   RLM_MAX_DEPTH        — Max recursion depth
#   RLM_MAX_TOKENS       — Max tokens per LLM response
#   RLM_PLUGINS          — Comma-separated plugin names to load
#   RLM_PLUGINS_DIR      — Directory containing plugin .md files
#   RLM_CHILD_SYSTEM_PROMPT — Custom system prompt for this child (set by parent)
#
# Internal environment (set by rlm, visible to children):
#   RLM_WORKDIR          — This invocation's working directory
#   RLM_ANSWER_FILE      — Path where RETURN writes the answer
#   RLM_INPUT            — Path to piped stdin data (if any)
#   RLM_DEPTH            — Current recursion depth
#   RLM_INVOCATION_ID    — Unique ID for this invocation
#   RLM_PARENT_ID        — Parent's invocation ID
#   RLM_ROOT_QUERY       — The root task (truncated to 200 chars)
#   RLM_LINEAGE          — Colon-separated query trail
#   RLM_EFFECTIVE_MAX_ITERS — Iteration budget for this depth
# ============================================================================

RLM_MAX_ITERATIONS="${RLM_MAX_ITERATIONS:-15}"
RLM_MAX_DEPTH="${RLM_MAX_DEPTH:-3}"
RLM_MAX_TOKENS="${RLM_MAX_TOKENS:-16384}"
RLM_MODEL="${RLM_MODEL:-anthropic/claude-sonnet-4}"

source "$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)/_rlm-common.sh"

SYSTEM_PROMPT='IMPORTANT: Do NOT use function calling or tool use. Respond ONLY with plain text containing ```repl code blocks.

You solve tasks by writing and executing code in a persistent Linux environment.

Write code in a single ```repl fenced block per response. Every response MUST contain at least one ```repl block. Code outside ```repl fences is not executed.

**Only one code block per response is executed.** If you write more than one, only the first runs — the rest are silently discarded. Write your reasoning as plain text, then write exactly one code block, then stop. Wait for the output before planning your next step.

When you have your final answer, call RETURN "value" inside a ```repl block. RETURN is the ONLY way to deliver your answer. Do not simply state the answer in prose.

## How to Work

Each iteration is one step. Do one thing, observe the result, then plan the next step.

1. **Explore** — inspect the data. Use cat, head, wc, file, etc. If input is large, sample it.
2. **Plan** — decide strategy. For large tasks, design a delegation structure.
3. **Execute** — compute directly or delegate to children.
4. **Verify** — print your candidate answer. Read the output to confirm.
5. **Return** — only RETURN "answer" after you have seen the correct value printed.

Your iterations are finite. Do not waste them — each one should make measurable progress. Do not narrate future steps or hypothesize about what output will look like. Write code, stop, read the actual output, and adapt.

## Delegation

- `llm "query"` — a single call to a language model. Fast, cheap, one-shot.
  No REPL, no code execution. Costs 1 API call. Prefer for simple tasks:
  classify an item, extract a value, answer a factual question.
  Pipe data with: echo "data" | llm "query"

- `rlm "query"` — recursive call to another RLM with its own REPL loop,
  iteration budget, and code execution. Powerful but expensive (3-15 API
  calls). Use for complex subtasks that need iteration.
  Pipe data with: echo "data" | rlm "query"
  Pass a custom system prompt with: RLM_CHILD_SYSTEM_PROMPT="..." rlm "query"

The filesystem is shared across all rlm calls. /context/ is for data you
intend to share across the recursion tree. Write working files to your own
directory; avoid concurrent writes to the same path.

## Designing Delegation

Prefer `llm` over `rlm` when the subtask is simple. Each `rlm` call
multiplies API cost by 3-15x. Use `rlm` only when the child needs to
write code, iterate, or delegate further.

You have bash, python3, jq, curl, git, and all standard Unix tools. You can install more with apt or pip.

Files persist across turns, but variables do not — each code block runs in a fresh shell. Use the filesystem for intermediate state.

Respond with plain text and exactly one ```repl fenced code block. Then stop and wait for the result.

If input was piped to this invocation, it is saved at $RLM_INPUT. Process it programmatically — it may be larger than your context window.'

if [ $# -lt 1 ]; then
	echo "Usage: rlm \"query\"" >&2
	exit 1
fi

query="$1"

emit_metadata() {
	# Emit structured metadata to stderr for eval harness/drivers to parse.
	# Suppressed in mock/test mode to avoid polluting test output.
	[ -n "${_RLM_MOCK_DIR:-}" ] && return 0
	local iters="${1:-0}"
	local wdir="${2:-${RLM_WORKDIR:-}}"
	echo "rlm-meta: {\"iterations\":$iters,\"workdir\":\"$wdir\"}" >&2
}

RLM_DEPTH="${RLM_DEPTH:-0}"

BASE_SYSTEM_PROMPT='You are a helpful assistant. Answer the question directly and concisely.'

if [ "$RLM_DEPTH" -ge "$RLM_MAX_DEPTH" ]; then
	# Base case: single LLM call, no loop, no code execution.
	# Uses the simpler BASE_SYSTEM_PROMPT (no mention of RETURN, code blocks, or sandbox).
	if [ -n "${_RLM_MOCK_DIR:-}" ]; then
		# In mock mode, read from base.md if it exists, otherwise diagnostic only
		base_file="$_RLM_MOCK_DIR/base.md"
		if [ -f "$base_file" ]; then
			printf '%s\n' "$(cat "$base_file")"
		fi
		echo "rlm: base case (depth $RLM_DEPTH >= max $RLM_MAX_DEPTH)" >&2
		emit_metadata 1 ""
		exit 0
	fi
	base_messages="[{\"role\":\"user\",\"content\":$(printf '%s' "$query" | jq -Rs .)}]"
	base_response=$(printf '%s' "$base_messages" | call_llm 1 "$BASE_SYSTEM_PROMPT") || {
		echo "rlm: base case LLM call failed" >&2
		emit_metadata 1 ""
		exit 1
	}
	printf '%s\n' "$base_response"
	emit_metadata 1 ""
	exit 0
fi

_SELF_DEPTH="$RLM_DEPTH"

# Capture and clear parent's custom system prompt (single-hop: parent->child only).
_CHILD_SYSTEM_PROMPT="${RLM_CHILD_SYSTEM_PROMPT:-}"
unset RLM_CHILD_SYSTEM_PROMPT

export RLM_DEPTH=$((RLM_DEPTH + 1))

_RLM_SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
case ":$PATH:" in
	*":$_RLM_SCRIPT_DIR:"*) ;;  # already on PATH
	*) export PATH="$_RLM_SCRIPT_DIR:$PATH" ;;
esac

if [ "$_SELF_DEPTH" -eq 0 ]; then
	export RLM_INVOCATION_ID="root"
	export RLM_PARENT_ID=""
	export RLM_ROOT_QUERY="${query:0:200}"
	export RLM_LINEAGE="$query"
else
	export RLM_INVOCATION_ID="d${_SELF_DEPTH}-c$$"
	export RLM_PARENT_ID="${RLM_PARENT_ID:-root}"
	export RLM_ROOT_QUERY="${RLM_ROOT_QUERY:-${query:0:200}}"
	export RLM_LINEAGE="${RLM_LINEAGE:+${RLM_LINEAGE}:}${query}"
fi

compute_iteration_budget() {
	local depth="$1"
	local max_iters="$2"
	case "$depth" in
		0) echo "$max_iters" ;;
		1) echo $(( max_iters < 7 ? max_iters : 7 )) ;;
		2) echo $(( max_iters < 4 ? max_iters : 4 )) ;;
		*) echo $(( max_iters < 3 ? max_iters : 3 )) ;;
	esac
}

RLM_EFFECTIVE_MAX_ITERS=$(compute_iteration_budget "$_SELF_DEPTH" "$RLM_MAX_ITERATIONS")
export RLM_EFFECTIVE_MAX_ITERS

if [ -n "$_CHILD_SYSTEM_PROMPT" ]; then
	# Parent provided custom instructions. Build a child-specific prompt:
	# custom instructions + minimal environment docs + orientation block.
	CHILD_REPL_SECTION='

## Environment

- Code runs in ```repl fenced blocks (bash). Each block executes in a fresh shell.
- RETURN "value" — return your final answer.
- llm "query" — one-shot LLM call for simple subtasks.
- rlm "query" — delegate to a child RLM (only if you need iteration/code execution).
- Files persist across iterations. Use the filesystem for state.
- If input was piped, it is at $RLM_INPUT.

Write exactly one ```repl fenced block per response. Only the first block is executed; additional blocks are discarded. Then stop and wait for the result.'

	SYSTEM_PROMPT="${_CHILD_SYSTEM_PROMPT}${CHILD_REPL_SECTION}"
fi

load_plugins() {
	local IFS=','
	local driver_bodies=""
	local app_bodies=""
	local app_count=0
	for name in $1; do
		local file="${RLM_PLUGINS_DIR:-$_RLM_SCRIPT_DIR/../plugins}/${name}.md"
		if [[ ! -f "$file" ]]; then
			echo "rlm: warning: plugin '$name' not found at $file" >&2
			continue
		fi
		local kind
		kind=$(awk '/^---$/{fm++; next} fm==1 && /^kind:/{print $2; exit}' "$file")
		local body
		body=$(awk 'BEGIN{fm=0} /^---$/{if(fm<2){fm++;next}} fm>=2{print}' "$file")
		if [[ "$kind" == "app" ]]; then
			((app_count++)) || true
			if [[ -n "$app_bodies" ]]; then
				app_bodies="${app_bodies}

---

${body}"
			else
				app_bodies="$body"
			fi
		else
			if [[ -n "$driver_bodies" ]]; then
				driver_bodies="${driver_bodies}

---

${body}"
			else
				driver_bodies="$body"
			fi
		fi
	done
	if [[ "$app_count" -gt 1 ]]; then
		echo "rlm: warning: multiple apps loaded; only one app per run is recommended" >&2
	fi
	# Drivers first, then apps — app task architecture wins in prompt positioning
	local plugin_bodies=""
	if [[ -n "$driver_bodies" && -n "$app_bodies" ]]; then
		plugin_bodies="${driver_bodies}

---

${app_bodies}"
	elif [[ -n "$driver_bodies" ]]; then
		plugin_bodies="$driver_bodies"
	else
		plugin_bodies="$app_bodies"
	fi
	echo "$plugin_bodies"
}

if [[ -n "${RLM_PLUGINS:-}" ]]; then
	plugin_text=$(load_plugins "$RLM_PLUGINS")
	if [[ -n "$plugin_text" ]]; then
		SYSTEM_PROMPT="${SYSTEM_PROMPT}

---

${plugin_text}"
	fi
fi

_RLM_TREE_ROOT="${_RLM_TREE_ROOT:-/rlm/tree}"  # testing seam

if [ -n "${_RLM_RESUME_DIR:-}" ]; then
	RLM_WORKDIR="$_RLM_RESUME_DIR"
else
	PARENT_WORKDIR="${RLM_WORKDIR:-}"
	if [ -z "$PARENT_WORKDIR" ]; then
		RLM_WORKDIR="${_RLM_TREE_ROOT}/$$"
	else
		RLM_WORKDIR="${PARENT_WORKDIR}/children/$$"
	fi
fi
mkdir -p "$RLM_WORKDIR/trace" "$RLM_WORKDIR/children"
export RLM_WORKDIR

# When resuming from an existing workdir, compute the starting iteration from
# the number of existing trace response files.
_start_iteration=1
if [ -n "${_RLM_RESUME_DIR:-}" ]; then
	_existing_responses=$(ls -1 "$RLM_WORKDIR/trace/"*-response.md 2>/dev/null | wc -l | tr -d ' ')
	_start_iteration=$((_existing_responses + 1))
fi

RLM_ANSWER_FILE="$RLM_WORKDIR/answer"
export RLM_ANSWER_FILE

printf '%s' "$query" > "$RLM_WORKDIR/query"

if [ ! -t 0 ]; then
	cat > "$RLM_WORKDIR/input"
	if [ -s "$RLM_WORKDIR/input" ]; then
		export RLM_INPUT="$RLM_WORKDIR/input"
	else
		rm -f "$RLM_WORKDIR/input"
	fi
fi

if [ -n "${RLM_INPUT:-}" ]; then
	input_size=$(wc -c < "$RLM_INPUT" | tr -d ' ')
	SYSTEM_PROMPT="${SYSTEM_PROMPT}

CRITICAL: Input data (${input_size} bytes) has been piped to this invocation and saved at \$RLM_INPUT. You MUST read this file to answer the question. Do not answer from memory — the answer is in the input data."
fi

build_orientation() {
	local self_depth="$1"
	local max_depth="$2"
	local effective_iters="$3"
	local invocation_id="$4"
	local parent_id="$5"
	local root_query="$6"
	local max_depth_0=$((max_depth - 1))

	echo ""
	echo "## Your Position"
	echo ""

	if [ "$self_depth" -eq 0 ]; then
		echo "Agent \"${invocation_id}\" — depth ${self_depth} of ${max_depth_0} (0-indexed)."
		echo "You are the root orchestrator."
	else
		echo "Agent \"${invocation_id}\" — depth ${self_depth} of ${max_depth_0} (0-indexed)."
		echo "Parent: \"${parent_id}\". Root task: \"${root_query}\""
	fi

	echo "Iteration budget: ${effective_iters} iterations."

	if [ "$self_depth" -ge $((max_depth - 1)) ]; then
		echo "Your rlm children will run in FLAT MODE (one-shot, no REPL, no sandbox). Pass all data directly in the query."
	elif [ "$self_depth" -ge $((max_depth - 2)) ]; then
		echo "Your children will be REPL agents at depth $((self_depth + 1))."
		echo ""
		echo "IMPORTANT: Your children are at the deepest REPL level."
		echo "Any rlm calls THEY make will be flat/one-shot (no code, no iteration)."
		echo "Design child tasks to be self-contained."
	else
		echo "Your children will be REPL agents at depth $((self_depth + 1))."
	fi
}

orientation_text=$(build_orientation "$_SELF_DEPTH" "$RLM_MAX_DEPTH" \
	"$RLM_EFFECTIVE_MAX_ITERS" "$RLM_INVOCATION_ID" "${RLM_PARENT_ID:-}" \
	"${RLM_ROOT_QUERY:-}")

SYSTEM_PROMPT="${SYSTEM_PROMPT}

${orientation_text}"

# --- Functions ---------------------------------------------------------------

extract_code_blocks() {
	# Parse ```repl blocks from stdin, write each to a numbered .sh file, print the dir.
	local blocks_dir
	blocks_dir="$(mktemp -d)"

	local return_fn
	return_fn='RETURN() {
    printf '\''%s'\'' "$1" > "$RLM_ANSWER_FILE"
}'

	local in_repl_block=false
	local block_num=0
	local current_block=""

	while IFS= read -r line || [ -n "$line" ]; do
		if $in_repl_block; then
			if [[ "$line" =~ ^'```'[[:space:]]*$ ]]; then
				((block_num++))
				printf '%s\n\n%s' "$return_fn" "$current_block" > "$blocks_dir/$block_num.sh"
				in_repl_block=false
				current_block=""
			else
				if [ -z "$current_block" ]; then
					current_block="$line"
				else
					current_block="$current_block
$line"
				fi
			fi
		else
			if [[ "$line" =~ ^'```repl'[[:space:]]*$ ]]; then
				in_repl_block=true
				current_block=""
			fi
		fi
	done

	echo "$blocks_dir"
}

execute_block() {
	# Run a .sh block, write output to trace, print output to stdout.
	local block_file="$1"
	local iteration="${2:-1}"
	local block_num="${3:-1}"

	local output=""
	local exit_code=0
	output="$(cd "$RLM_WORKDIR" && bash "$block_file" 2>&1)" || exit_code=$?

	if [ "$exit_code" -ne 0 ]; then
		output="[Exit code: $exit_code]
$output"
	fi

	local padded
	padded=$(printf '%03d' "$iteration")
	printf '%s' "$output" > "$RLM_WORKDIR/trace/${padded}-output.txt"

	printf '%s' "$output"
}

truncate_output() {
	# Produce a head+tail truncated version of output for the LLM message.
	local full_output="$1"
	local trace_path="$2"

	local _RLM_TRUNCATE_MAX_BYTES="${_RLM_TRUNCATE_MAX_BYTES:-51200}"
	local _RLM_TRUNCATE_MAX_LINES="${_RLM_TRUNCATE_MAX_LINES:-1000}"
	local _RLM_TRUNCATE_HEAD="${_RLM_TRUNCATE_HEAD:-50}"
	local _RLM_TRUNCATE_TAIL="${_RLM_TRUNCATE_TAIL:-20}"

	local byte_count
	byte_count=$(printf '%s' "$full_output" | wc -c | tr -d ' ')
	local line_count
	line_count=$(printf '%s' "$full_output" | wc -l | tr -d ' ')

	if [ "$byte_count" -le "$_RLM_TRUNCATE_MAX_BYTES" ] && [ "$line_count" -le "$_RLM_TRUNCATE_MAX_LINES" ]; then
		printf '%s' "$full_output"
		return 0
	fi

	local size_display
	if [ "$byte_count" -ge 1048576 ]; then
		size_display="$((byte_count / 1048576))MB"
	elif [ "$byte_count" -ge 1024 ]; then
		size_display="$((byte_count / 1024))KB"
	else
		size_display="${byte_count}B"
	fi

	local head_lines
	head_lines=$(printf '%s' "$full_output" | head -n "$_RLM_TRUNCATE_HEAD")
	local tail_lines
	tail_lines=$(printf '%s' "$full_output" | tail -n "$_RLM_TRUNCATE_TAIL")

	printf '[Output truncated. Full output: %s (%s, %s lines)]\nFirst %d lines:\n%s\nLast %d lines:\n%s' \
		"$trace_path" "$size_display" "$line_count" \
		"$_RLM_TRUNCATE_HEAD" "$head_lines" \
		"$_RLM_TRUNCATE_TAIL" "$tail_lines"
}

build_messages() {
	# Reconstruct the conversation JSON from query + trace files.
	local messages
	messages="[{\"role\":\"user\",\"content\":$(jq -Rs . "$RLM_WORKDIR/query")}]"

	for resp in "$RLM_WORKDIR/trace/"*-response.md; do
		[ -f "$resp" ] || break
		local full_output_file="${resp/-response.md/-output.txt}"
		local truncated_output_file="${resp/-response.md/-output-truncated.txt}"

		local output_file="$full_output_file"
		if [ -f "$truncated_output_file" ]; then
			output_file="$truncated_output_file"
		fi

		if [ -f "$output_file" ]; then  # complete iteration
			messages=$(echo "$messages" | jq \
				--rawfile r "$resp" \
				--rawfile o "$output_file" \
				'. + [{"role":"assistant","content":$r},{"role":"user","content":$o}]')
		fi
	done

	echo "$messages"
}

# --- Main Loop ---------------------------------------------------------------

consecutive_no_code=0

for ((iteration=_start_iteration; iteration<=RLM_EFFECTIVE_MAX_ITERS; iteration++)); do
	messages=$(build_messages)

	response=$(echo "$messages" | call_llm "$iteration") || {
		echo "rlm: LLM call failed at iteration $iteration" >&2
		emit_metadata "$iteration"
		exit 1
	}

	padded=$(printf '%03d' "$iteration")
	printf '%s' "$response" > "$RLM_WORKDIR/trace/${padded}-response.md"

	blocks_dir=$(echo "$response" | extract_code_blocks)

	if [ -z "$(ls -A "$blocks_dir" 2>/dev/null)" ]; then
		((consecutive_no_code++)) || true

		if [ "$consecutive_no_code" -ge 2 ]; then
			echo "rlm: two consecutive responses with no code blocks" >&2
			rm -rf "$blocks_dir"
			emit_metadata "$iteration"
			exit 1
		fi

		no_code_msg='Your response contained no executable code blocks. Wrap code in ```repl fences.'
		printf '%s' "$no_code_msg" > "$RLM_WORKDIR/trace/${padded}-output.txt"
		rm -rf "$blocks_dir"
		continue
	fi

	consecutive_no_code=0

	# Single-block enforcement: only execute the first code block.
	# Count total blocks and warn if extras are discarded.
	block_files=("$blocks_dir"/*.sh)
	total_blocks=${#block_files[@]}

	if [ "$total_blocks" -gt 1 ]; then
		discarded=$((total_blocks - 1))
		echo "rlm: discarding $discarded additional code block(s) (single-block mode)" >&2
	fi

	# Execute only the first block.
	first_block="${block_files[0]}"
	iteration_output=""
	if [ -f "$first_block" ]; then
		output=$(execute_block "$first_block" "$iteration" 1)

		iteration_output="$output"

		# Append discard warning to output so the LLM sees it in feedback.
		if [ "$total_blocks" -gt 1 ]; then
			discard_warning="[WARNING] $discarded extra code block(s) were discarded. Only the first block was executed. Write ONE code block per response and wait for real output before writing the next step."
			if [ -n "$iteration_output" ]; then
				iteration_output="$iteration_output
$discard_warning"
			else
				iteration_output="$discard_warning"
			fi
		fi

		if [ -f "$RLM_ANSWER_FILE" ]; then
			answer=$(cat "$RLM_ANSWER_FILE")
			printf '%s\n' "$answer"
			rm -rf "$blocks_dir"
			emit_metadata "$iteration"
			exit 0
		fi
	fi

	if [ -z "$iteration_output" ]; then
		iteration_output="[No output. Your code ran successfully but produced no stdout/stderr. If you redirected to a file, read it back or use RETURN.]"
	fi
	printf '%s' "$iteration_output" > "$RLM_WORKDIR/trace/${padded}-output.txt"

	truncated=$(truncate_output "$iteration_output" "$RLM_WORKDIR/trace/${padded}-output.txt")
	if [ "$truncated" != "$iteration_output" ]; then
		printf '%s' "$truncated" > "$RLM_WORKDIR/trace/${padded}-output-truncated.txt"
	fi

	rm -rf "$blocks_dir"
done

# If we get here, we exhausted max iterations without RETURN
echo "rlm: max iterations ($RLM_EFFECTIVE_MAX_ITERS) reached without RETURN" >&2
emit_metadata "$RLM_EFFECTIVE_MAX_ITERS"
exit 1
